<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>对象——若干属性的集合</title>
    <script type="text/javascript" src="../../../html/html-html/tool.js"></script>
    <script type="text/javascript" src="../../../html/jQuery-Ajax/js/jquery-3.3.1.js"></script>
</head>
<body>

<script type="text/javascript">

    function Fn() {
    }

    Fn.prototype.name = '王福朋';
    Fn.prototype.getYear = function () {
        return 1988;
    };


    /**
     * 所有的函数都有prototype,所有的对象都有隐藏的属性 __proto__
     *
     * 函数相当于java的类
     * 对象就相当于java实例化后的对象
     *
     * prototype在构造方法中
     *
     * @type {Fn}
     */

    var fn = new Fn();//--------------非常重要必须是 new 出来的才可以调用prototype原型属性
    // console.log(fn.name);
    // console.log(fn.getYear());
    //
    // console.log(fn);
    // console.log(Fn);
    //打印 可知prototype其实是一个函数(我实在是受不了 java里叫函数) 它在构造方法里,
    // 当你new 对象时就会执行fn.__proto__ = Fn.prototype  然后你就可以fn.name  我也不知道为什么


    // Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性
    // 因为每个对象都有一个隐藏的属性——“__proto__”，这个属性引用了创建这个对象的函数的prototype。即：fn.__proto__ = Fn.prototype


    // var fn1 = new Function("x", "y", "return x+y");
    // Ulog.i("fn1", fn1(5, 6));
    // var obj = {a: 10, b: 20};
    // Ulog.i(obj);

    function Person() {
    }

    Person.prototype.name = '王福朋';
    Person.prototype.getYear = function () {
        return 1988;
    };
    var p = new Person();


    console.log(Person.prototype); // Object{}
    console.log(p ); //undefined

    console.log(p.__proto__ ==Person.prototype); //true

</script>


<button onclick='alert("test");'>点击</button>
<button onclick="alert('test');">点击</button>
</body>
</html>